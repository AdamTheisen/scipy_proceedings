:author: Sebastián Sepúlveda
:email: ssepulveda.sm@gmail.com
:institution: Escuela de Ingeniería Civil Biomédica, Facultad de Ingeniería, Universidad de Valparaíso

:author: Pablo Reyes
:email: pablo.reyes@uv.cl
:institution: Escuela de Ingeniería Civil Biomédica, Facultad de Ingeniería, Universidad de Valparaíso

:author: Alejandro Weinstein
:email: alejandro.weinstein@uv.cl
:institution: Escuela de Ingeniería Civil Biomédica, Facultad de Ingeniería, Universidad de Valparaíso

:video: http://bit.ly/1BHObxL
:video: http://bit.ly/1Ex0Ydy

------------------------------------------------
Visualizing physiological signals in real time
------------------------------------------------

.. class:: abstract

This work presents a software, written in Python, to visualize and record in real time physiological signals, such as electrocardiography,  electromyography and human movement. The software is also capable of doing real time processing, such as filtering and spectral estimation. The software is open source, extensible, multi-platform and has been tested on different Linux distributions, including the RaspberryPi (ARM architecture). It leverages the use of several libraries, including PyQtGraph and the SciPy/NumPy stack.

.. class:: keywords

   real time processing, visualization, signal processing

Introduction
------------

A common task in biomedical research is to record and visualize in real time physiological signals. Although there are several options to do this, they are commonly based on  proprietary tools, associated to a particular signal acquisition device vendor. This work presents an open source software, written in Python, to visualize and record in real time physiological signals, such as electrocardiography, electromyography and human movement. The software is also capable of doing real time processing, such as filtering and spectral estimation. The software is open source [#]_  and extensible. It is easy to add new signal processing tasks and to use different signal sources (serial, Bluetooth, Sockets, etc.), and customize the user interface for the applications needs.

.. [#] Available at https://github.com/ssepulveda/RTGraph.

The main objective of the software is to display in real time multiple signals and to export them to a file. In the current implementation, The communication between the software and the acquisition device is through the serial port, and it is implemented using the PySerial library. Other communication protocols can be easily added. The real time display of the signals is implemented using the PyQtGraph library. [#]_ The software has a multiprocess architecture, based on the multiprocessing Python standard library. This allows having concurrent processes for receiving, processing, and displaying the data. Signal processing tasks, such as spectral estimation, are based on the SciPy stack. This architecture assures that no data is loosed and a fast response of the user interface.

.. [#] Available at http://www.pyqtgraph.org.

The software is multi-platform and runs in any machine and OS where Python and the corresponding dependencies can be installed. The software has been tested on different Linux distributions, including the RaspberryPi (ARM architecture).


Software architecture
---------------------

The applications described in this work can be classified as a "data logger". A data logger needs to acquire a stream of data, add a time stamp to the data (if required), and export the time-stamped data to a file in a known file format, such as comma separated value (CSV) format. Optionally, the application can do some processing (filtering, spectral estimation, etc.) before saving the data. In addition, it is also useful to be able to visualize, in real time, the stream of data.

When developing, evaluating, or validating a new hardware or software, it is important to have  control of the outcome of the algorithms and the fidelity and performance of the data acquisition process. In particular, in the field of Biomedical Engineering, the acquisition and signal processing of biological signals needs to be reliable and with a tight control over the sampling frequency. It is also fundamental to ensure that no data is lost during the acquisition and logging process. From a practical point of view, having to wait for the data to be stored before visualizing it (possibly in another program) is cumbersome and tedious, slowing down the development process. For these reasons, in this work we present a program able of: receiving data from a variety of sources (serial port, Bluetooth, Zigbee, Sockets, etc.); processing and visualizing the data in real time; and recording the data in a file.

The first version of this program was developed for a research on Biomechanical engineering. This research involves logging, processing, and real time displaying of the signals generated by a nine degrees of freedom inertial measurement unit (9DOF-IMU). This requires acquiring nine signals with a sampling rate of at least 100 hertz. Six additional signals are computed through a sensor fusion algorithm. A total of 15 signals are displayed and exported as a CSV file. We designed the architecture of the program with these requirements in mind.


Real time graphics library
==========================

Real time visualization is a key component of our program. To satisfy our requirements we needed a fast and portable graphics library. Since we implemented the GUI in PyQT, we also required that the graphics library should be embeddable in this framework.

We used Matplotlib [B]_ in the first version of the program. This option worked out of the box. We were able to embed a Matplotlib plot in the GUI and interact with it trough other elements of the UI without major complications. Although this approach worked for displaying one signal with a sampling rate of 30 hertz, we started to notice a degradation on performance as we increased the number of signals. It is important to notice that this is not a flaw of Matplotlib, since the main focus of the library is the production of publication of quality figures, and not the display of real time data.

Next, we tried was PyQtGraph [A]_. It is a pure Python implementation, with a focus on speed, portability and a rich set of features. Unlike the previous libraries that we tried, PyQtGraph was designed to do real time plotting. It is also designed to do interactive image analysis. It is built on top of PyQt4/PySide, giving easy integration and full compatibility with the Qt framework. This allows the use of tools like Qt Designer to design the GUI. Using Qt Designer and the examples provides with the PyQtGraph library, it is easy to configure and customize the widgets. PyQtGraph is also built on top of NumPy, facilitating and improving the performance of the manipulation of numerical data. In addition, PyQtGraph wraps up some NumPy/SciPy signal processing functions such as the Fast Fourier Transform and some linear and non-linear filters. [#]_

.. [#] We also evaluated the PyQwt library (http://qwt.sourceforge.net/). This library provides a Python interface to the Qwt library. It is a light implementation with an easy QT integration. It is fast enough to support real time display of the data. However, this library is not currently maintained, and its author recommend using PyQtGraph (see http://comments.gmane.org/gmane.comp.graphics.qwt.python/506).


Threading versus Multiprocessing
================================

After using PyQtGraph to its limits in a multithreaded architecture, we could not reliably achieve the desired performance. The limitations of threads in Python [E]_ combined with the interaction between the UI (main thread) and communication thread, resulted in data losses when the data rate was too large. The Global Interpreter Lock (GIL) [E]_ prevents threads to take advantage of multicore systems. In short, it means that a mutex controls the access from threads to the memory. There are ways to work around this limitation. For instance, many of the NumPy primitives take advantage of multiple cores. [#]_ However, in our case we need to parallelize the reception of the data, the visualization, the processing, and the logging.

.. [#] See http://wiki.scipy.org/ParallelProgramming for details.

To overcome the GIL limitations we used the multiprocessing module, belonging to the Python Standard Library. This module provides an API similar to the threading module, but it uses subprocesses instead of threads [D]_. By letting the OS to control of the subprocesses, this allows to take advantage of all the cores available on the platform.

Putting all together
====================

Once the key components of the program has been selected, the remaining problem is to orchestrate the communication among the processes. We pay special attention to data synchronization, since there are specific considerations that should be taken into account when working with multiple processes.

Figure :ref:`figSWarch` shows the architecture of the software. The architecture allow us to: (1) Have a multiplatform program. (2) Have a separation between the reception and parsing of input data stream and the plotting and logging tasks. The following is a description of each process.

1. Communication process: This process is responsible of receiving and parsing the data stream send by the device. The implementation considers an abstract class, that subclasses the ``Process`` class from the ``multiprocessing`` library. Therefore, the methods  ``__init__`` and ``run`` are overwritten. We also added methods ``start`` and ``stop`` to properly start and stop the subprocesses. The class also have methods common to different communication protocols (serial, sockets, etc.). The details of each protocol is implemented in each subclass. This process is also responsible of validating the data and adding the time-stamp to the data, in case the device does not have it. This guarantee that the data is always time-stamped.

2. Main process: The main process is responsible of initializing the different subprocesses and of coordinating the communication between them. As shown in figure :ref:`figSWarch`, this process instantiates the components that will allow the communication between the subprocesses and also manage the different UI elements. A ``Queue``, as implemented by the ``multiprocessing`` module, is used to communicate the communication with the main process. A ``QtTimer`` is set to update the real time plot. By updating the plot at a known frequency, we can control the responsiveness of the program under different conditions. Each time the ``QtTimer`` triggers a plot update (30 times per second), the ``queue`` is processed. The queue is read until is empty and then the plot is updated.

.. figure:: sw_architecture.pdf

   Diagram of the software architecture. There are two independent processes. The communication process reads the incoming data stream, parse it, add a time-stamp (if necessary), and put the processed data into a queue. The main process reads the data from the queue, process the data, and then update the plot and log the data into a file. :label:`figSWarch`


Programming details
-------------------

The template for the communication process is implemented through the ``CommunicationProcess`` class. This template allows to process data streams coming from a variety of protocols (serial, sockets, bluetooth, etc.). The design of the class  also allows changing some of the communication parameters during run-time. In addition, since the class inherits from the ``Process`` class, it is trivial to run several instances of the class to receive from multiple devices simultaneously. For instance, it is possible to instantiate the class twice to receive data form two different serial ports at the same time. The following code snippet shows how the basic structure of the class. The figure :ref:`usage` shows how the architecture of the program would work as processes managed by the OS.

.. code-block:: python

	class CommunicationProcess(Process):
	    def __init__(self, queue):
	        Process.__init__(self)
            self.exit = Event()
            self.queue = queue
            """
            Initialize the process
            Initialize the acquisition method.
            """

            def run(self):
                self.init_time = time()
                try:
                    while not self.exit.is_set():
                        """
                        do acquisition and add time stamp
                        """
                except:
                    raise
                finally:
                    self.closePort()

            def openPort(self, port):
                """
                Port configuration to open
                """

            def closePort():
                self.exit.set()

.. figure:: usage.png

   The screen shot shows the htop tool while running the software. This tools allows to see the processes running filtered by the software. In the screen shot, the process PID 1082 corresponds to the first process initiated by the application. The process PID 1178 corresponds to the acquisition process, child process of the PID 1082. The other child are threads in the corresponding processes, principally for the Qt elements. :label:`usage`


Results
-------

The software presented in this work is able to work with a serial port data stream of ASCII data, representing one signal with 4 digits, corresponding to a sampling frequency of 2 kilohertz. It is also able to work with a socket data stream consisting of 20 signals with a sampling rate of 500 hertz.

In general, the sampling rate on serial communications would be limited to the baud rate of the transmission and how the data is transfered. In general, in a common 115200/8N1 serial configuration, a bit is transfered every 8.68055 microseconds. A transfer will be composed for 8 bits, plus an ending bit, giving 78.12495 microseconds per transfer. This gives a maximum sampling rate 12.8 KHz for a byte. This will be lowered every time another character is added to the transfer. As mentioned in the example, we reached a 2 KHz using 4 digits (4 bytes), plus to characters for the carriage return and new line (to match the CSV format), giving us 6 bytes transfered at 2 KHz (2333.33469 Hz, to be precise).

In a biomechanical study we used our program to evaluate a prototype of a wearable device used to estimate muscle fatigue through the EMG signal. The software was customized to acquire and record data. We also added some steps of the fatigue estimation algorithm [F]_ to the processing pipeline. In this case we found that having real time feedback of the signal simplified  the procedure to position the wearable device correctly positioned, drastically reducing the amount of time required by the experiments.

Figure :ref:`emg` shows a screen shot of the program while acquiring an EMG signal from a study using wearables devices to study fatigue in muscles. Figure :ref:`device` shows a photo of the device connected through the serial port.

.. figure:: emg.png
    
    Screen shot of the software customized and modified to display 3 signals, an EMG signal, followed by the processed signal to calculate the fatigue indicator, and finally three signals of acceleration, corresponding for the three axis. :label:`emg`

.. figure:: emg.png
    
    Photo of the prototype device used in the study. An Arduino development platform is used to acquire the signals, and transfered to a computer running the software. :label:`device`


An important feature of our program is the easiness to customize it to a specific application. For instance, the software is being used to acquire a set of pressure signals from a device used to monitor monitor nutrition disorders in premature infants. The customization included: (1) modifying the software acquire two pressure signals from the serial port; and (2) to perform some specific signal processing before displaying  to display the results of the monitoring. In this example it is important to emphasize that the changes to the program were made by a researcher different than the main developer of our program. We claim that this is possible because our program is written in Python. This makes it easier to understand and modify the code than a program written in a lower level language.

See the following links for two examples where the software is used to acquire EMG signals from different devices: http://bit.ly/1BHObxL, http://bit.ly/1Ex0Ydy.

The software presented in this work has been tested with different devices, communication protocols, platforms and operating systems (OSs). The initial development was done and tested on the platforms x86, x64 and ARM (RaspberryPy) running Linux. However, this version of the software did not worked as expected on OS X and Windows, due to some restrictions of the multiprocessing library in these OSs. Despite the fact that OS X is a Unix-like OS, there are some multiprocessing methods not implemented in the multiprocessing library. In particular, the method ``qsize``, used to get the approximated size of the queue, is not implemented in OS X. The lack of the ``os.fork()`` call in Windows add some extra limitation when running a program on this OS. Since in this case a child process can not access the parent resources, it is necessary that subclasses of the ``Process`` class must be picklable. Although the documentation of the library contains some suggestions to overcome this restrictions, currently we are not able to run our program on Windows.

Conclusions
-----------

In this work we presented a program developed to record, process and visualize physiological signals in real time. Although many people consider Python as a "slow" language, this work shows that it is possible to use Python to write applications able to work in real time. At the same time, the clarity and simplicity of Python allowed us to end up in a program that it is easy to modify and extend, even by people who is not familiar with the base code.

We also believe that our solution is a contribution to the open source and Do It Yourself (DIY) communities. Typically, programs to receive and manipulate data in real time are developed using proprietary tools such as LabView or MATLAB. The cost of these tools prevent users of these communities to have access to solutions like the described in this work.


This software could lead to good solution for rapid prototyping and for the growing community based on the open source and DIY. Has shown in the Use cases, most of the devices are prototyped with development platforms like Arduino. This software could help in the development of similar projects, even in more general engineering projects or others fields. A more general software could be developed to enable the DIY and electronics enthusiast to have simple tools to start in the electronics and programming world.

In the future our first priority is to make our program work in platforms running OS X and Windows. We are currently investigating how to overcome the restriction imposed by the multiprocessing platform on these OSs. Next, we will focus on improving the UI. In particular, we will add the option to change the software behavior, in terms of plot and processing parameters, on the fly, instead of requiring a change in the source code. Finally, we will refactor the architecture of the program to improve the performance, so we can handle higher data rates. In this respect, the main change we plan to do is to move the signal processing computation to another process, leveraging the existence of multi-core machines.


Acknowledgments
---------------

This research was partially supported by the Advanced Center for Electrical and
Electronic Engineering, Basal Project FB0008, Conicyt.

References
----------
.. [A] L. Campagnola. *PyQtGraph. Scientific Graphics and GUI Library for Python*,
        http://www.pyqtgraph.org/

.. [B] J. D. Hunter. *Matplotlib: A 2D graphics environment*,
        Computing In Science & Engineering, 9(3):90-95, IEEE COMPUTER SOC, 2007.

.. [D] Python Software Foundation, *16.6 multiprocessing - Process-based “threading” interface*,
        https://docs.python.org/2/library/multiprocessing.html

.. [E] Beazley, David. *Understanding the python gil*,
        In PyCON Python Conference. Atlanta, Georgia. 2010.

.. [F] S. Madgwick, Andrew JL Harrison, and Ravi Vaidyanathan. *Estimation of IMU and MARG orientation using a gradient descent algorithm.*,
        Rehabilitation Robotics (ICORR), 2011 IEEE International Conference on. IEEE, 2011.

..  LocalWords:  electromyography SciPy NumPy biomedical RaspberryPi PySerial multiprocess
