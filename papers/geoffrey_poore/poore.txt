`````````````{=rst}
:author: Geoffrey M. Poore
:email: gpoore@uu.edu
:institution: Union University
:bibliography: poore


=======================================
Codebraid: Live Code in Pandoc Markdown
=======================================


.. class:: abstract

   Codebraid executes designated inline code and code blocks in Pandoc
   Markdown documents as part of the document build process.  It includes a
   lightweight, low-overhead code execution system.  Alternatively, code can
   be executed with Jupyter kernels.  Regardless of how code is executed, a
   single document can involve multiple programming languages, as well as
   multiple independent sessions or processes per language.  All code
   extraction and output insertion is performed on Pandoc's abstract syntax
   tree (AST) representation of a document, rather than on the original
   Markdown source.  Because Codebraid only relies on standard Pandoc Markdown
   syntax, Pandoc handles all Markdown parsing and format conversions.  In the
   final output document, a code chunk can be replaced by a display of any
   combination of its original Markdown source, its code, the stdout or stderr
   resulting from execution, or rich output in the case of Jupyter kernels.
   There is also support for programmatically copying code or output to other
   parts of a document.


.. class:: keywords

   reproducibility, dynamic report generation, literate programming, Python,
   Project Jupyter


Introduction
============

Scientific and technical documents are increasingly written with software that
allows a mixture of text and executable code, such as the Jupyter Notebook
:cite:`Kluyver2016`, knitr :cite:`Xie2015`, and Org-mode Babel
:cite:`Schulte2011,Schulte2012`.  Writing with such tools can enhance
reproducibility, simplify code documentation, and aid in automating reports.

This paper introduces Codebraid, which allows executable code within Pandoc
Markdown documents :cite:`pandoc`.  To put Codebraid in context, the next
section is devoted to a review of existing tools that allow a mixture of text
and executable code, with a focus on those that support Markdown.  This
emphasizes three categories that are particularly relevant for comparing with
Codebraid's capabilities:

* Code execution and language support

* Display of code and its output

* Document format and parsing



Review
======


Org-mode Babel
--------------

.. https://orgmode.org/worg/org-contrib/babel/
.. https://orgmode.org/worg/org-contrib/babel/languages.html
.. https://orgmode.org/worg/org-contrib/babel/languages/
.. https://orgmode.org/manual/Specific-header-arguments.htm
.. https://orgmode.org/manual/session.html

Babel :cite:`Schulte2011,Schulte2012` allows code blocks and inline code in
Emacs Org-mode documents to be executed.  Any number of languages can be used
within a single document.  By default, each code chunk is executed
individually in its own process.  For many interpreted languages, it is also
possible to run code in a session so that data and variables persist between
code chunks.  In those cases, multiple named sessions per language are
possible.  This allows computations to be spread over several code chunks,
while simultaneously making it possible to separate independent computations
into separate sessions so that code is only re-executed when necessary.

.. https://orgmode.org/manual/file.html#file
.. https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-gnuplot.html

Any combination of code and its stdout can be displayed.  Stdout can be
shown verbatim or interpreted as Org-mode, HTML, or LaTeX markup.  For
some languages, such as gnuplot, graphical output can also be captured and
included automatically.

Packages like ob-ipython :cite:`ob-ipython` and emacs-jupyter
:cite:`emacs-jupyter` make it possible to use Jupyter kernels
:cite:`Kluyver2016` instead of Babel's built-in code execution system.  These
add the capability to include error messages or rich output like graphics
within a document.  The Emacs IPython Notebook :cite:`ein` takes a different
approach by providing a complete Jupyter Notebook client in Emacs.

.. https://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming

Babel can function as a meta-programming language for Org mode.  A code chunk
can be named, and then a later code chunk—potentially in a different
language—can access its output by name and perform further processing.
Similarly, there are literate programming capabilities that allow a code chunk
to copy the source of one or more named chunks into itself, essentially
serving as a template, before execution.


.. https://pandoc.org/org.html

Org-mode documents can be converted into a number of other formats such as
HTML and LaTeX.  Although the format is typically used with Emacs, Pandoc
supports a subset of Org mode which does not include Babel.  An Org-mode
document using Babel features can first be processed with Emacs to evaluate
code, and then the plain Org-mode output can be used with Pandoc.



knitr
-----

.. https://leisch.userweb.mwn.de/Sweave/
.. https://rstudio.github.io/reticulate/index.html
.. https://cran.r-project.org/web/packages/JuliaCall/index.html
.. https://rmarkdown.rstudio.com/lesson-2.html

Sweave :cite:`Leisch2002` was one of the first programs for combining text
with executable code, allowing R within LaTeX.  It was a primary inspiration
for knitr :cite:`Xie2015`, which provides powerful R evaluation in LaTeX and
additional formats like Markdown and HTML.  More recently, the reticulate
:cite:`reticulate` and JuliaCall :cite:`juliacall` packages for R have given
knitr significant Python and Julia capabilities.  These include the ability to
convert objects between Python and R or Julia and R.  knitr is commonly used
with the RStudio IDE, which provides a two-panel source-and-output preview interface as well as a notebook-style mode with inline display of results.

.. https://bookdown.org/yihui/rmarkdown/language-engines.html

All R, Python, and Julia code chunks are executed in language-specific
sessions, so data and variables persist between code chunks for each
individual language.  Unlike Org-mode Babel, knitr is limited to a single
session for each of these languages.  Many additional languages are also
supported, with the restriction that each code chunk is executed in its own
separate process.  Though knitr does not include any support for Jupyter
kernels, the knitron :cite:`knitron` and ipython_from_R :cite:`ipython-from-R`
packages have demonstrated that this is technically feasible.

.. https://yihui.name/knitr/demo/reference/

R, Python, and Julia code blocks can display any combination of code, output,
and plots.  There are a number of code-block options for customizing plot
display, including plot layout, dimensions, and captions.  It is possible to
use code chunk references (``ref.label``) to insert the code or output of a
named code chunk at another location.  Inline code can be executed to print
the output of expressions.

.. https://github.com/rstudio/rmarkdown/issues/974
.. https://github.com/yihui/knitr/issues/1363
.. https://rviews.rstudio.com/2017/12/04/how-to-show-r-inline-code-blocks-in-r-markdown/
.. https://yihui.name/knitr/faq/



`````````````


When knitr is used with Markdown, custom Markdown syntax is used for defining
code block options and designating inline code that will be executed.  Fenced code blocks begin with options of the form

``````
```{r key1 = value1, key2 = value2}
``````

Meanwhile, inline code takes the form `` `r <expression>` ``.  A preprocessor
is used to extract the code from the original Markdown source, and then output
is inserted into a copy of the document that can be processed with Pandoc.
While this approach minimizes the overhead associated with code extraction and
output insertion, the preprocessor can introduce significant cognitive load
for users.  For example, knitr's preprocessor employs simple regex matching
and does not understand Markdown comments, so code in a commented-out part of
a document still runs.  Writing tutorials that show literal knitr code chunks
can involve inserting empty strings, zero-width spaces, linebreaks, or Unicode
escapes to avoid the preprocessor's tendency to execute code
``:cite:`knitrfaq,Hovorka` ``{=rst}.



`````````````{=rst}


Jupyter Notebook
----------------

The Jupyter (formerly IPython) Notebook :cite:`Kluyver2016` provides a
browser-based user interface in which a document is represented as a series of
cells.  A cell may contain Markdown (which is converted into HTML and
displayed when not being edited), raw text, or code.  Code is executed by
language-specific backends, or kernels.  Well over one hundred kernels are
available beyond Python, including Julia, R, bash, and even compiled languages
like C++ and Rust :cite:`jupyter-kernels`.  While Jupyter kernels are often
used with the notebook, they can be used separately as a standalone code
execution system, such as the Org-mode integration mentioned above.

A Jupyter Notebook can only have a single kernel, and thus only a single
primary programming language in a single session or process.  This means that
within a single notebook, separating independent computations into separate
sessions or processes is typically not as straightforward as it might be in
Org-mode Babel.  However, the interactive nature of the notebook often reduces
the impact of this limitation, and can actually be a significant advantage.
Code cells can be run one at a time; a single code cell can be modified and
run again within rerunning any previous code cells.

There are multiple ways to work around the single-kernel-per-notebook
limitation.  The IPython kernel provides ``%%script`` and similar "magics"
:cite:`ipython-magics` that can execute a cell with another language.
Each cell is executed individually in its own subprocess, so there is no
persistence of data and variables between such cells.  Magics provided by
PyJulia :cite:`PyJulia` and rpy2 :cite:`RPy2` avoid this limitation so that an
IPython kernel can interact with a single Julia or R session over a series of
cells (see :cite:`Bussonnier2018` for examples).  Some broader approaches to
working around this limitation are provided by the BeakerX polyglot magics
:cite:`BeakerX`, which support bidirectional autotranslation of data between
languages, and the Script of Scripts (SoS) kernel :cite:`SoS`, which acts as a
managing kernel over multiple normal kernels.

Jupyter code cells correspond to code blocks in Org-mode Babel or knitr.
There is no built-in support for executing inline code within Markdown cells.
This is possible with the Python Markdown extension
:cite:`jupyter:pymarkdown`, so long as inline code is outside LaTeX equations.
The extension also supports notebook export to other document formats with
nbconvert :cite:`nbconvert` via a bundled preprocessor.

In the browser interface, Jupyter notebooks display code, stdout, stderr, and
rich output such as plots (when supported by the kernel).  All output can be
hidden by double-clicking next to it in the left margin.  Hiding code is
currently only possible with extensions :cite:`jupyter:codefolding,jupyter:hideallinput,jupyter:hideinput`.

.. https://nbconvert.readthedocs.io/en/latest/config_options.html
.. https://jupyter.org/jupyter-book/features/hiding.html
.. https://nbconvert.readthedocs.io/en/latest/customizing.html

Notebooks can be exported to document formats such as HTML and PDF with
nbconvert :cite:`nbconvert`, the Jupyter notebook conversion program.  Hiding
code or output in exported documents is possible on a notebook-wide basis by
configuring nbconvert with the TemplateExporter exclude options.  It is also
possible at the individual cell level by adding a tag to a cell (View, Cell
Toolbar, Tags, then "Add tag") and then configuring nbconvert to use the
desired TagRemovePreprocessor with a given tag.  An alternative is to use
extensions with their provided preprocessors or templates
:cite:`jupyter:codefolding,jupyter:hideinput`, or employ a more inclusive tool
like Jupyter Book :cite:`JupyterBook` that defines a set of tags for display
customization.

While Org-mode and knitr documents are saved as markup, Jupyter notebooks are
saved in JSON format in ipynb files.  By default, notebook files contain all
code and Markdown from notebook cells, as well as all output including rich
output like plot images.  It is possible to simplify notebook files by
excluding output.  Since JSON can be less convenient than markup for working
with version control systems, special diffing tools such as nbdime
:cite:`nbdime` have been developed.



Jupyter Notebooks as Markdown or code plus comments
---------------------------------------------------

There are a number of programs that represent Jupyter Notebooks using Markdown
or source code plus comments rather than the standard JSON in an ipynb file.
This avoids potential version control hassles with JSON, can facilitate
conversion of notebooks into other document formats, and allows notebooks to
be edited in any text editor, not just the browser-based notebook interface.

.. https://pandoc.org/MANUAL.html#creating-jupyter-notebooks-with-pandoc
.. https://github.com/jgm/pandoc/releases/tag/2.6

Pandoc :cite:`pandoc` added the ability to convert to or from ipynb files with
version 2.6 in January 2019.  The following examples are quoted from the
Pandoc manual.  In Markdown, code cells can be represented most simply as a
fenced code block with language "code":

`````````````


``````
``` code
print("hello")
```
``````

It is also possible to create code cells with attributes and output.  The
sequences of colons in this case are Pandoc's fenced divs, with attributes
delimited by curly braces:

``````
:::::: {.cell .code execution_count=1}
``` {.python}
print("hello")
```

::: {.output .stream .stdout}
```
hello
```
:::
::::::
``````

`````````````{=rst}

Pandoc's ipynb support offers new ways to control how a notebook is converted
into other document formats.  For example, filters can be created that
manipulate a notebook once it has been converted into Pandoc's AST
representation.

.. https://github.com/podoc/podoc
.. https://github.com/rossant/ipymd



`````````````

Before Pandoc added ipynb support, it was possible to convert between Markdown
and ipynb with Pandoc via podoc ``:cite:`podoc` ``{=rst}, which provides
conversion between ipynb and Pandoc's AST.  podoc was created by Cyrille
Rossant as the primary tool for writing the second edition of *IPython
Interactive Computing and Visualization Cookbook* (2018)
``:cite:`ipython-cookbook,writing-ipython-cookbook` ``{=rst}.  It represents a
significantly more advanced implemention of what Rossant had previously
created in ipymd ``:cite:`ipymd` ``{=rst}.

With podoc, a code cell is represented by a simple fenced code block with the
language name, so the first Pandoc example would start with ` ```python`
instead.  This does bring the limitation that all code blocks are code cells;
there are no code blocks that simply represent literal code that is not
executed.  Similarly, output is represented as code blocks beginning with `
```{output:stdout}`, and images generated by an executed code block become
Markdown images included immediately after the code block.

podoc also includes a ``ContentsManager`` subclass for the Jupyter Notebook.
This allows the podoc representation of a notebook in Markdown to be loaded as
a notebook, or a notebook to be saved as Markdown.

`````````````{=rst}

.. https://github.com/aaren/notedown

Similar notebook-Markdown conversion capabilities are provided by notedown
:cite:`notedown`.  Unlike podoc, notedown allows configuration of which types
of Markdown code blocks are converted into notebook code cells.  This allows
code blocks representing literal code that is not executed.  notedown can also
convert R Markdown (knitr) documents into Jupyter notebooks.  Like podoc, it
includes a ``ContentsManager`` subclass for the notebook so that Markdown can
be used as the saved format.

.. https://github.com/mwouts/jupytext
.. https://jupytext.readthedocs.io/en/latest/

Jupytext :cite:`jupytext` can convert Jupyter notebooks into Markdown or R
Markdown, or into scripts in which code cells are converted into code while
Markdown cells are converted into intervening comments.  These formats can
also be converted into Jupyter notebooks.  Multiple Markdown representations
of a code cell are possible.  The standard form is similar to that of Pandoc:

`````````````

``````
```python <metadata>
<code>
```
``````

`````````````{=rst}

With Jupytext, it is possible to work with a Jupyter notebook in the browser,
then save it in script form via the Jupytext menu in the Jupyter Notebook,
edit the script in a text editor until it performs as desired, and finally
refresh the notebook in the browser to update the notebook code from the
script.  Like podoc and notedown, this involves a ``ContentsManager``.

.. https://nteract.gitbooks.io/hydrogen/docs/Usage/NotebookFiles.html
.. https://nteract.gitbooks.io/hydrogen/docs/Usage/GettingStarted.html
.. https://code.visualstudio.com/docs/python/jupyter-support

The Hydrogen package :cite:`hydrogen` for the Atom text editor also provides
conversion between ipynb notebook files and source code plus comments.  For
example, in Python a comment of the form ``# %%`` precedes code that
corresponds to a code cell, while a comment like ``# %% markdown`` precedes an
extended comment containing the Markdown text of a Markdown cell.  When such a
code file is edited within Atom, Hydrogen can connect to a Jupyter kernel so
that a "code cell" can be executed and rich output like plots or tables
displayed next to it within the editor.  Similar notebook conversion, code
execution, and display capabilities are provided by the Python extension for
VS Code :cite:`python-vscode`.



Jupyter kernels in Markdown or other formats
--------------------------------------------

The tools discussed in the last subsection represent alternate ways of
interacting with a Jupyter notebook.  This subsection provides an overview of
programs that combine Jupyter kernels with Markdown or other formats to
provide a different or broader set of features than what is possible with a
default notebook (or at least what was possible with a default notebook at the
time the program was initially developed).

.. http://mpastell.com/pweave/

Pweave :cite:`pweave` is inspired by Sweave :cite:`Leisch2002` and knitr
:cite:`Xie2015`, with a focus on Python in Markdown and other formats like
LaTeX and reStructuredText.  A source code format with Markdown in comments is
also supported.  It uses Markdown syntax very similar to knitr's, with many
similar features and options.  Python code is executed with a Jupyter kernel,
and rich output like plots can be included automatically.  Although Pweave is
focused on Python, it can be used with any Jupyter kernel (one kernel is
allowed per file).  Pweave documents support inline code execution, provide
options for hiding code or its output, can execute code to emulate a terminal
session, and incorporate code block options for customizing figure display.

.. http://weavejl.mpastell.com/stable/

Weave.jl :cite:`weavejl-joss`, by the creator of Pweave, is very similar,
except that it is focused on executing Julia code.  It uses Julia to manage
code execution rather than a Jupyter kernel.

.. https://github.com/jankatins/knitpy
.. https://github.com/pystitch/stitch

knitpy :cite:`knitpy` describes itself as a port of knitr to Python.  It uses
knitr-style Markdown syntax, and provides code block options to control code
and output display.  Other knitr-style options are not supported.  Code is
executed in a single Jupyter Python kernel.  stitch :cite:`stitch` is similar,
drawing inspiration from knitr and knitpy.  Compared to knitpy, it lacks
options for customizing output display but has options for customizing figure
display.

.. https://github.com/jhrmnn/knitj



`````````````

Knitj ``:cite:`knitj` ``{=rst} is another Jupyter kernel–Markdown integration.
It uses fenced codeblocks with the language name at the beginning, such as `
```python`.  Options for controling display are contained in special comments
in the first line of code within a code block.  For example, `#::hide`.  Knitj
can serve an HTML document derived from Markdown.  When the Markdown is
modified, it detects which code chunks were modified and only re-evaluates
them with the Jupyter kernel before pushing  updates to the HTML via
WebSocket.


`````````````{=rst}

.. https://github.com/matthew-brett/nb2plots

Although this review is primarily focused on Markdown, there are some similar
tools for reStructuredText.  nb2plots can convert an ipynb notebook into
reStructuredText for Sphinx :cite:`nb2plots`.  When Sphinx builds the files,
the code is still executed and plots are automatically included, so the live
code and rich output of the notebook are not lost.  It is possible to
customize display by hiding code.  The reStructuredText can also be converted
to a Python source file or ipynb when that is desired.

.. https://jupyter-sphinx.readthedocs.io/en/latest/

The Jupyter Sphinx Extension :cite:`jupyter-sphinx` provides a
``jupyter-execute`` directive for running code in a Jupyter kernel.  By
default, code is executed within a single kernel, providing continuity.  It is
also possible to switch to a different kernel or switch to a different session
using the same kernel type.  Code and output (including rich output like
plots) are displayed by default, but there are options for hiding code or output, or reversing their order.  All code for a given Jupyter session can be converted into a script or a Jupyter notebook.



`````````````


# A simple Codebraid example

A simple Pandoc Markdown document that runs code with Codebraid is shown below.

```{.cb.paste copy=part1+part2 show=copied_markup name=copied_source hide_markup_keys=name}
```

`..`{=rst}



Pandoc Markdown defines attributes for inline code and code blocks.  These have the general form

```
{#id .class1 .class2 key1=value1 key2=value2}
```

If code with these attributes were converted into HTML, `#id` becomes an HTML
id for the code, anything with the form `.class` specifies classes, and
space-separated key-value pairs provide additional attributes.  Although
key-value pairs can be quoted with double quotation marks, Pandoc allows most
characters except the space and equals sign unquoted.  Other output formats
such as LaTeX use attributes in a largely equivalent manner.

Pandoc uses the first class to determine the language name for syntax
highlighting, hence the `.python` in the example above.  Codebraid uses the
second class to specify a command for processing the code.  All Codebraid
commands are under a `cb` namespace to prevent unintentional collisions with
normal Pandoc inline code and code blocks.  In this case, `cb.run` indicates
that code should be run, stdout should be included and interpreted as
Markdown, and stderr should be displayed in the event of errors.  Finally, in
this example, the `name` keyword is used to assign a unique name to each piece
of code.  This allows the code to be referenced elsewhere in a document to
insert any combination of its Markdown source, code, stdout, and stderr.

If this were a normal Pandoc document, converting it into a format such as
reStructuredText could be accomplished by running

```
pandoc --from markdown --to rst file.md
```

Using Codebraid to execute code as part of the document conversion process is
as simple as replacing `pandoc` with `codebraid pandoc`:

```
codebraid pandoc --from markdown --to rst file.md
```

The `codebraid` executable is available from the Python Package Index (PyPI);
development is at https://github.com/gpoore/codebraid.

When this `codebraid pandoc` command is executed, the original Markdown shown
above is converted into the Codebraid-processed Markdown

```{.cb.paste copy=part1+part2 show=stdout:verbatim name=paste_verbatim hide_markup_keys=name}
```

This processed Markdown would then be converted into the final
reStructuredText, rendering as

> ```{.python .cb.run name=part1}
> var1 = "Hello from *Python!*"
> var2 = f"Here is some math:  $2^8={2**8}$."
> ```
>
> ```{.python .cb.run name=part2}
> print(var1)
> print(var2)
> ```


`..`{=rst}

By default, the output of `cb.run` is interpreted as Markdown.  It is possible
to show the output verbatim instead, as discussed later.

In this example, the code is simple enough that it could be executed every time the document is built, but that will often not be the case.  By default,
Codebraid caches all code output, and code is only re-executed when it is modified.  This can be changed by building with the flag `--no-cache`.

# Creating examples

The example in the last section was actually itself an example of using
Codebraid.  This paper was written in Markdown, then converted to
reStructuredText via Codebraid with Pandoc.  Finally, the reStructuredText was
converted through LaTeX to PDF via ``Docutils :cite:`docutils` ``{=rst}.  The
two code blocks in the example were only entered in the original Markdown
source of this paper a single time, and Codebraid only executed them a single
time.  However, with Codebraid's copy-paste capabilities, it was possible to
display the code and output in other locations in the document
programmatically.

The rendered output of the two code blocks is shown at the very end of the
last section.  This is where the code blocks were actually entered in the
original Markdown source of this paper, and where they were executed.

Recall that both blocks were given names, `part1` and `part2`.  This enables
any combination of their Markdown source, code, stdout, and stderr to be
inserted elsewhere in the document.  At the beginning of the previous section,
the Markdown source for the blocks was shown.  This was accomplished via

```{.cb.paste copy=copied_source show=copied_markup}
```

The `cb.paste` command inserts copied data from one or more code chunks that
are specified with the `copy` keyword.   Meanwhile, the `show` keyword
controls what is displayed.  In this case, the Markdown source of the copied
code chunks was shown.  Since the `cb.paste` command is copying content from
elsewhere, it is used with an empty code block.  Alternatively, a single empty
line or a single line containing an underscore is allowed as a placeholder.

Toward the end of the last section, the verbatim output of the
Codebraid-processed Markdown was displayed.  This was inserted in a similar
manner:

```{.cb.paste copy=paste_verbatim show=copied_markup}
```

The default format of `stdout` is `verbatim`, but this was specified just to be explicit.  The other option is `raw`, or interpreted as Markdown.

Of course, all Markdown shown in the current section was itself inserted
programmatically using `cb.paste` to copy from the previous section.  However,
to prevent infinite recursion, the next section is not devoted to explaining
how this was accomplished.


# Other Codebraid commands

The commands `cb.run` and `cb.paste` have already been introduced.  There
are three additional commands.

The `cb.code` command simply displays code, like normal inline code or a code
block.  It primarily exists so that normal code can be named, and then
accessed later.  `cb.paste` could be used to insert the code elsewhere,
perhaps combined with code from other sources via something like
`copy=code1+code2`.  It would also be possible to run the code elsewhere:

``````
```{.cb.run copy=code1+code2}
```
``````

When `copy` is used with `cb.run`, or another command that executes code, only
code is copied, and everything proceeds as if this code had been entered
directly in the code block.

The `cb.expr` command only works with inline code, unlike other commands.  It
evaluates an expression and then prints a string representation.  For example,

```{.cb.paste copy=inline_expr show=copied_markup}
```

produces

> `2**128`{.python .cb.expr name=inline_expr hide_markup_keys=name}

As this demonstrates, Pandoc code attributes for inline code immediately
follow the closing backtick(s).  While this sort of a "postfix" notation may
not be ideal from some perspectives, it is the cost of maintaining full
compatibility with Pandoc Markdown syntax.

Finally, the `cb.nb` command runs code in "notebook mode."  For code blocks,
this displays code followed by verbatim stdout.  If there are errors, stderr
is also included automatically.  For inline code, `cb.nb` is equivalent to `cb.expr`.  The markdown

```{.cb.paste copy=notebook show=copied_markup}
```

results in

```{.python .cb.nb name=notebook session=nb hide_markup_keys=session}
import random
random.seed(2)
rnums = [random.randrange(100) for n in range(8)]
print(f"Random numbers: {rnums}")
print(f"Sorted numbers: {sorted(rnums)}")
print(f"Range: {[min(rnums), max(rnums)]}")
```

# Display options

There are two code chunk keywords that govern display, `show` and `hide`.
These can be used to override the default display settings for each command.

`show` takes any combination of the following options: `markup` (display
Markdown source), `code`, `stdout`, `stderr`, and `none`.  Multiple options
can be combined, such as `show=code+stdout+stderr`.  Code chunks using `copy`
can also employ `copied_markup` to display the Markdown source of the copied
code chunk.  When the `cb.expr` command is used, the expression output is
available via `expr`.  `show` completely overwrites the existing display
settings.

The display format can also be specified with `show`.  `stdout`, `stderr`, and
`expr` can take the formats `raw` (interpreted as Markdown), `verbatim`, or
`verbatim_or_empty` (verbatim if there is output, otherwise a space or empty
line).  For example, `show=stdout:raw+stderr:verbatim`.  While a format can be
specified for `markup` and `code`, only the default `verbatim` is permitted.

`hide` takes the same options as `show`, except that `none` is replaced by
`all` and formats are not specified.  Instead of overriding existing settings
like `show`, `hide` removes the specified display options from those that
currently exist.


# Advanced code execution

Ideally, executable code should arranged within a document based on what is
best for the reader, rather than in a manner dictated by limitations of the
tooling.  Several options are provided to maximize the flexibility of code
presentation.

## Incomplete units of code

By default, Codebraid requires that code be divided into complete units.  For
example, a code block must contain an entire loop, or an entire function
definition.  Codebraid can detect the presence of an incomplete unit of code
because it interferes with stdout and stderr processing, in which case Codebraid will raise an error.

The `complete` keyword allows incomplete units of code.  While this increases
the flexibility of code layout, it also means that any output will not be
shown until the next complete code chunk.

The Markdown for a somewhat contrived example that demonstrates these
capabilities is shown below, along with its output.

```{.cb.paste copy=loop1+loop2+loop3 show=copied_markup}
```

> ```{.python .cb.run complete=false name=loop1 session=loop hide_markup_keys=session+name}
> for n in range(11):
> ```
>
> ```{.python .cb.run complete=false name=loop2 session=loop hide_markup_keys=session+name}
>     if n % 2 == 0:
> ```
>
> ```{.python .cb.run name=loop3 session=loop hide_markup_keys=session+name}
>         if n < 10:
>             print(f"{n}, ", end="")
>         else:
>             print(f"{n}")
> ```

`..`{=rst}


## Sessions

By default, all code for a language is executed within a single session, so
variables and data are shared between code chunks.  It can be convenient to
separate code into multiple sessions when several independent tasks are being
performed, or when a long calculation is required but the output can easily be
saved and loaded by separate code for visualization or other processing.  The
`session` keyword makes this possible.  For example,

```{.cb.paste copy=long show=copied_markup}
```

```{.python .cb.run session=long name=long hide_markup_keys=name}
import json
result = sum(range(100_000_000))
with open("result.json", "w") as f:
    json.dump({"result": result}, f)
```

All sessions are currently executed in serial.  In the future, support for
parallel execution may be added.


## Outside `main()`

Codebraid's built-in code execution system runs code by inserting it into a
template.  The template allows stdout and stderr to be broken into pieces and
correctly associated with the code chunks that created them.  For a language
like Python under typical usage, `complete` eliminates the few limitations of
this approach.  However, the situation for a compiled language with a `main()`
function is more complex.

Codebraid includes support for Rust.  By default, code is inserted into a
template that defines a `main()` function.  Thus, a code block like

```{.cb.paste copy=simple_rust show=copied_markup}
```

can run to produce

> ```{.rust .cb.run name=simple_rust session=simple_rust hide_markup_keys=name+session}
> let x = "Greetings from *Rust!*";
> println!("{}", x);
> ```

`..`{=rst}

In some situations, it would be convenient to completely control the
definition of the `main()` function and add code outside of `main()`.  The
`outside_main` keyword makes this possible.  All code chunks with
`outside_main=true` at the beginning of a session are used to overwrite the
beginning of the `main()` template, while any chunks with `outside_main=true`
at the end of the session are used to overwrite the end of the template.  If
all code chunks have `outside_main=true`, then all of Codebraid's templates
are completely omitted, and all output is associated with the final code
chunk.  The example below demonstrates this option.

```{.cb.paste copy=complex_rust show=copied_markup}
```

> ```{.rust .cb.run outside_main=true name=complex_rust session=complex_rust hide_markup_keys=name+session}
> fn main() {
>     use std::fmt::Write as FmtWrite;
>     use std::io::Write as IoWrite;
>     let x = "Rust says hello.  Again!";
>     println!("{}", x);
> }
> ```

`..`{=rst}


# Working with external files

Though Codebraid is focused on embedding executable code within a document,
there will be times when it is useful to interact with external source files.
Since Codebraid processes code with a programming language's standard
interpreter or compiler, normal module systems are fully compatible; for
example, in Python, `import` works normally.  Codebraid provides additional
ways to work with external files via the `include_file` option.

When `include_file` is used with the `cb.code` command, an external source
file is simply included and displayed.  It is possible to include only certain
line ranges using the additional option `include_lines`, or only part of a
file that matches a regular expression via `include_regex`.  For example,

```{.cb.paste copy=include show=copied_markup
copied_markup_rewrap_lines=true copied_markup_rewrap_width=55}
```

includes the original Markdown source for this paper, and then uses a regular
expression to display only the first few lines of the current section:

```{.markdown .cb.code include_file=poore.txt
code_rewrap_lines=true code_rewrap_width=55
include_regex="# Working.*?," name=include
hide_markup_keys=name+code_rewrap_lines+code_rewrap_width}
```

Since the `cb.code` command is including content from elsewhere, it is used
with an empty code block. Alternatively, a single empty line or a single line
containing an underscore is allowed as a placeholder.  This example included
part of a file using a single regular expression.  There are also options for
including everything starting with or starting after a literal string or
regular expression, and for including everything before or through a literal
string or regular expression.

The `include_file` option works with commands that execute code as well.  For instance,

``````
```{.python .cb.run include_file=code.py}
```
``````

would read in the contents of an external file "code.py" and then run it in
the default Python session, just as if it had been entered directly within the
Markdown file.


# Implementation and language support

Codebraid currently supports Python 3.5+, Julia, Rust, R, Bash, and
JavaScript.  This section provides an overview of how code is executed and the
procedure for adding support for additional languages.

Unless `outside_main=true` or `complete=false`, code is inserted into a
template before execution.  The template writes delimiters to stdout and
stderr at the beginning of each code chunk.  These delimiters are based on a
hash of the code to eliminate the potential for collisions.  Once execution is
complete, Codebraid parses stdout and stderr and uses these delimiters to
associate output with individual code chunks.  This is why using
`outside_main=true` or `complete=false` delays the inclusion of output to a
later code chunk; there are no delimiters.  This system is a more advanced
variant of the one I created previously in PythonTeX ``:cite:`Poore2015`
``{=rst}.

Each individual delimiter is unique, and is tracked individually by Codebraid.
This allows incomplete units of code that have not been marked with
`complete=false` to be detected.  If this code interferes with the template to
produce an error, Codebraid can use the stderr delimiters plus parsing of
stderr to find the source.  If the code does not produce an error, but
prevents a delimiter from being written or causes a delimiter to be written
multiple times or not at the beginning of a line, this will also be detected
and traced back.  Under normal conditions, interfering with the delimiters
without detection requires conscious effort.

Adding support for additional languages is simply a matter of creating the
necessary templates and putting them in a configuration file.  Basic language
support can require very little, essentially just code for writing the
delimiters to stdout and stderr.  For example, Bash support is based on this
three-line template:

```
printf "\n{stdout_delim}\n"
printf "\n{stderr_delim}\n" >&2
{code}
```

The Bash configuration file also specifies that the file extension `.sh`
should be used, and provides another four lines of template code to enable
`cb.expr`.  So far, the longest configuration file, for Rust, is less than
fifty lines—counting empty lines.


# Debugging

Because code is typically inserted into a template for execution, if there are
errors the line numbers will not correspond to those of the code that was
extracted from the document, but rather to those of the code that was actually
executed.  Codebraid tracks line numbers during template assembly, so that
executed line numbers can be converted into original line numbers.  Then it
parses stderr and corrects line numbers.  An example of an error produced with
`cb.nb` with Python is shown below.

```{.python .cb.nb session=error name=error
stderr_rewrap_lines=true stderr_rewrap_width=50}
var = 123
print(var, flush=True)
var += "a"
```

`..`{=rst}

Since line numbers in errors and warnings correspond to those in the code
entered by the user, and since anything written to stderr is displayed by
default next to the code that caused it, debugging is significantly
simplified.  In many cases, this even applies to compile errors, as can be
demonstrated with some Rust code in a new session.  First, define a variable:

```{.rust .cb.run session=debug show=code+stdout+stderr}
let number = 123;
```

Then introduce a syntax error:

```{.rust .cb.run session=debug show=code+stdout+stderr}
number -/
```

The compile error appears next to the code that caused it, with a line number
of 2, which is appropriate since this is the second line of code in this
session.


Another source of errors is invalid code chunk options or an invalid
combination of options.  In these cases, Codebraid omits everything that would
normally be displayed and instead provides an error message.  This includes
the line number in the Markdown source where the error occurred.  The Pandoc
AST does not currently contain source information.  Instead, Codebraid
performs a parallel string search through the Markdown source and the AST to
associate code with line numbers in the Markdown source.



`````````````{=rst}

Conclusion
==========

Codebraid provides a unique and powerful combination of features for executing
code embedded in Pandoc Markdown documents.  A single document can contain
multiple languages and multiple independent sessions per language.  Any
combination of Markdown source, code, stdout, and stderr can be displayed, and
it is easy to reuse code and output elsewhere in a document.

There are several logical avenues for further development.  One of the
original motivations for creating Codebraid was to build on my previous work
with PythonTeX :cite:`Poore2015` to create a code execution system that could
be used with multiple markup languages.  While Codebraid has focused thus far
on Pandoc Markdown, little of it is actually Markdown-specific.  It should be
possible to work with other markup languages supported by Pandoc, such as
LaTeX; all that is required is that Pandoc parses key-value attributes for
some variant of a code block.  Pandoc has recently added Jupyter notebooks to
its extensive list of supported formats.  Perhaps at some point it may even be
conceivable to convert a Codebraid document into a Jupyter notebook, perform
some exploratory programming for a single session of a single language, and
then convert back to Markdown.

Another, simpler integration with Jupyter would be to add support for running
code using Jupyter kernels rather than Codebraid's built-in system.
Codebraid's multiple independent sessions give it advantages for some types of
computations, but there are times when the responsiveness of a Jupyter kernel
would be convenient.  Pweave :cite:`pweave` has previously used Jupyter
kernels to execute code extracted from Markdown documents.

Codebraid's caching system could also be improved in the future.  Currently,
caching is based only on the code that is executed.  Adding a way to specify
external dependencies such as data files would be beneficial.

.. noweb and literate programming?

`````````````
